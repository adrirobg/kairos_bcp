# Kairos BCP: Sistema de Gesti√≥n de Conocimiento Personal

Kairos BCP es una aplicaci√≥n de Gesti√≥n de Conocimiento Personal (PKM) dise√±ada para permitir a los usuarios capturar, organizar, enlazar y recuperar informaci√≥n de manera eficiente[cite: 2]. Este sistema busca fomentar la creaci√≥n de una base de conocimiento personal interconectada[cite: 2].

Este README describe la arquitectura del backend, las tecnolog√≠as utilizadas y las directrices iniciales para el plan de desarrollo, derivados de una investigaci√≥n exhaustiva (referida como "Informe de Arquitectura Backend").

## üèõÔ∏è Arquitectura General y Estructura del Proyecto

La arquitectura elegida para el backend de Kairos BCP es la **Arquitectura Limpia (Clean Architecture)**, complementada con un **√©nfasis modular interno**[cite: 84, 85, 277]. Esta decisi√≥n se fundamenta en su capacidad superior para ofrecer alta mantenibilidad, testeabilidad y flexibilidad, cruciales para gestionar la complejidad de una aplicaci√≥n PKM y asegurar su evoluci√≥n a largo plazo[cite: 77, 78, 86].

### Principios Arquitect√≥nicos Clave:
* **Separaci√≥n de Responsabilidades Estricta**: El n√∫cleo de la aplicaci√≥n, que comprende la l√≥gica de negocio y las entidades, se mantiene aislado de los detalles de infraestructura como frameworks, la base de datos o la interfaz de usuario[cite: 39, 41, 86].
* **Regla de Dependencia**: Todas las dependencias de c√≥digo fuente apuntan estrictamente hacia el interior, hacia las capas de mayor nivel de abstracci√≥n (el dominio), protegiendo as√≠ el n√∫cleo de la aplicaci√≥n de cambios en las capas externas[cite: 39, 40, 147].
* **√ânfasis Modular Interno**: Aunque la aplicaci√≥n se despliega como un monolito, su c√≥digo se organiza internamente en m√≥dulos l√≥gicos. Estos m√≥dulos se basan en las funcionalidades principales del PKM (por ejemplo, gesti√≥n de notas, enlaces, b√∫squeda), inspir√°ndose en los principios del Monolito Modular para mejorar la organizaci√≥n y la escalabilidad del desarrollo sin introducir la complejidad de los microservicios[cite: 81, 95, 158, 278].

### Estructura de Directorios:
La estructura del proyecto est√° meticulosamente dise√±ada para reflejar estas capas y principios arquitect√≥nicos. Una descripci√≥n detallada se encuentra en la Secci√≥n V.A del "Informe de Arquitectura Backend" [cite: 115] y se puede explorar dentro del directorio `src/pkm_app/` de este proyecto. Esta estructura refuerza la separaci√≥n de responsabilidades y facilita la navegaci√≥n y comprensi√≥n del c√≥digo[cite: 280].

## ‚öôÔ∏è Tecnolog√≠as Clave y su Integraci√≥n

El backend de Kairos BCP utilizar√° el siguiente stack tecnol√≥gico, integrado seg√∫n los principios de la Arquitectura Limpia:

* **Python**: Como lenguaje principal para el desarrollo del backend, seleccionado por su simplicidad, legibilidad y el vasto ecosistema de librer√≠as y frameworks[cite: 14, 281].
* **PostgreSQL con pgvector**: Utilizado para la persistencia de datos relacionales y para habilitar capacidades de b√∫squeda vectorial sem√°ntica. La interacci√≥n con la base de datos se gestionar√° a trav√©s de implementaciones de repositorios en la capa de infraestructura[cite: 22, 23, 197, 281].
* **SQLAlchemy**: Actuar√° como el Object-Relational Mapper (ORM) para interactuar con PostgreSQL. Las implementaciones de repositorios encapsular√°n la l√≥gica de acceso a datos. Se recomienda el uso de las capacidades as√≠ncronas de SQLAlchemy, especialmente si se opta por FastAPI para la futura API[cite: 201, 234, 282].
* **Pydantic**: Desempe√±ar√° un rol central y ubicuo en la aplicaci√≥n para la definici√≥n de entidades de dominio, Value Objects, Data Transfer Objects (DTOs), schemas de API y la gesti√≥n de la configuraci√≥n. Su uso garantizar√° la validaci√≥n de datos y la robustez del sistema a trav√©s de todas las capas[cite: 138, 208, 282].
* **Streamlit**: Se emplear√° para construir la interfaz de usuario inicial. Esta UI interactuar√° con el backend a trav√©s de los Casos de Uso definidos en la capa de aplicaci√≥n, actuando como un cliente "delgado" de la l√≥gica de negocio[cite: 25, 217, 282].
* **FastAPI (Consideraci√≥n Futura)**: Es el framework preferido para el desarrollo de una API REST en el futuro, debido a su alto rendimiento, soporte as√≠ncrono nativo y excelente integraci√≥n con Pydantic[cite: 32, 35, 227, 282].

## üß© Organizaci√≥n Modular y Colaboraci√≥n

Para fomentar un desarrollo iterativo eficiente y facilitar la colaboraci√≥n, el c√≥digo dentro de las capas de la Arquitectura Limpia se organizar√° en **m√≥dulos l√≥gicos**. Estos m√≥dulos se definir√°n en torno a las principales funcionalidades o dominios del PKM (ej., `notes_module`, `linking_module`, `search_module`, `metadata_module`, `user_module`)[cite: 95, 159, 173, 278].

### Comunicaci√≥n Intermodular (Interna):
* **S√≠ncrona**: Se realizar√° mediante llamadas a los Casos de Uso (Servicios de Aplicaci√≥n) expuestos p√∫blicamente por cada m√≥dulo. Se podr√≠a adoptar el patr√≥n Gateway para definir interfaces claras y centralizadas para la comunicaci√≥n entre m√≥dulos[cite: 175, 176, 283].
* **As√≠ncrona**: Se implementar√° a trav√©s de un sistema de eventos interno. Esto permitir√° una comunicaci√≥n desacoplada, donde un m√≥dulo puede emitir un evento (ej. `NoteUpdatedEvent`) y otros m√≥dulos interesados pueden suscribirse y reaccionar a dicho evento sin crear dependencias directas. Esto es particularmente √∫til para manejar acciones en cascada dentro de la PKM[cite: 180, 181, 283].

### Testeabilidad:
La arquitectura adoptada facilita inherentemente la testeabilidad del sistema en diferentes niveles[cite: 10, 185, 283]:
* **Tests Unitarios**: Se enfocar√°n en probar la l√≥gica de negocio dentro de las entidades y servicios de dominio en total aislamiento[cite: 186]. Los casos de uso se probar√°n mockeando las dependencias externas (como los repositorios)[cite: 187, 188].
* **Tests de Integraci√≥n**: Verificar√°n la correcta integraci√≥n de los adaptadores de la capa de infraestructura con las herramientas externas reales, como la interacci√≥n de los repositorios SQLAlchemy con una base de datos de prueba (PostgreSQL/pgvector)[cite: 190, 191].

## üìù Plan de Dise√±o y Desarrollo (Directrices Iniciales)

Las siguientes directrices iniciales, extra√≠das del "Informe de Arquitectura Backend", guiar√°n el dise√±o y desarrollo de Kairos BCP:

1.  **Adopci√≥n de la Arquitectura**: Implementar la Arquitectura Limpia con un √©nfasis modular interno como la estructura fundamental del backend[cite: 84, 277].
2.  **Definici√≥n de la Estructura de Directorios**: Establecer la estructura de directorios propuesta en el informe (Secci√≥n V.A [cite: 115]), la cual est√° dise√±ada para reforzar la separaci√≥n de responsabilidades[cite: 279].
3.  **Dise√±o del Dominio**: Modelar las entidades de negocio principales (Notas, Enlaces, Tags, etc.) y Value Objects utilizando Pydantic para asegurar la integridad y validaci√≥n de los datos del dominio[cite: 138, 208].
4.  **Definici√≥n de Puertos**: Especificar las interfaces abstractas (Puertos) para los repositorios en la capa de aplicaci√≥n. Estas interfaces definir√°n los contratos para las operaciones de persistencia y consulta de datos que necesitar√°n los casos de uso[cite: 104, 122, 150, 198].
5.  **Desarrollo de Casos de Uso**: Implementar la l√≥gica de aplicaci√≥n para las funcionalidades prioritarias de la PKM, orquestando el flujo de datos y las interacciones con el dominio y los puertos[cite: 42, 105, 119].
6.  **Implementaci√≥n de Adaptadores de Persistencia**: Crear las clases de repositorio concretas que implementen las interfaces (puertos) definidas, utilizando SQLAlchemy para la interacci√≥n con PostgreSQL y pgvector[cite: 109, 124, 201].
7.  **Construcci√≥n de la UI Inicial**: Desarrollar la interfaz de usuario con Streamlit, asegurando que las vistas interact√∫en con el backend a trav√©s de los casos de uso definidos[cite: 93, 218, 219].
8.  **Estrategia de Testing Temprana**: Incorporar la escritura de tests unitarios y de integraci√≥n como parte integral del ciclo de desarrollo desde el inicio del proyecto[cite: 185, 190, 283].
9.  **Configuraci√≥n de Herramientas de Calidad**: Implementar y configurar herramientas de calidad de c√≥digo como linters, formateadores y analizadores est√°ticos (m√°s detalles se abordar√°n con el Prompt 5)[cite: 293].
10. **Consideraci√≥n de Comunicaci√≥n As√≠ncrona**: Dise√±ar los m√≥dulos teniendo en cuenta la posibilidad de una comunicaci√≥n basada en eventos para operaciones que se beneficien del desacoplamiento y el procesamiento en segundo plano[cite: 180, 182, 283].

## üìö Proyectos de Referencia

El dise√±o y desarrollo de Kairos BCP se inspirar√° en las mejores pr√°cticas observadas en varios proyectos de c√≥digo abierto bien estructurados. Algunos ejemplos notables incluyen:

* `bodaue/fastapi-clean-architecture`[cite: 31, 238]: Proporciona una plantilla moderna para aplicaciones FastAPI siguiendo la Arquitectura Limpia, con SQLAlchemy as√≠ncrono y Alembic.
* `arctikant/fastapi-modular-monolith-starter-kit`[cite: 32, 248]: Ofrece un excelente ejemplo de c√≥mo lograr modularidad interna dentro de un monolito, incluyendo la comunicaci√≥n intermodular y la gesti√≥n de componentes centrales.
* Ejemplos de Arquitectura Hexagonal: Proyectos como `serfer2/flask-hexagonal-architecture-api` [cite: 35, 259] y `workflows-guru/hexagonal-architecture` [cite: 34, 260] ilustran la implementaci√≥n pr√°ctica de Puertos y Adaptadores con Flask/FastAPI y SQLAlchemy.

La convergencia de herramientas como Pydantic, SQLAlchemy y Alembic dentro de estructuras como la Arquitectura Limpia/Hexagonal en estos proyectos de referencia sugiere un conjunto de patrones maduros y bien establecidos para construir backends Python robustos[cite: 275], proporcionando una base s√≥lida para Kairos BCP.